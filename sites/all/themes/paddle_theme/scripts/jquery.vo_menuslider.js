(function ($) {
  "use strict";
  $.fn.paddleThemeMenuSlider = function () {
    if (this.length === 0) {
      return this;
    }
      // Allows to have multiple instances of the same jquery plugin on the same
      // page.
    var classListener = this.selector;
    var innerContent = classListener + " > ul.menu";

    // reset vars
    var itemWidth = 0;
    var totalWidth = 0;
    var counter = 0;
    var noConflictCounter = 0;
    var innerWidth = $(classListener).width();

    function setControls(upperThis, noConflictCounter) {
      $(upperThis).after('<div class="menuslider-controls clearfix"><button class="menuslider-button" id="menuslider-prev" rel="[1,' + noConflictCounter + ']"><i class="fa fa-angle-left"></i><span class="element-invisible">' + Drupal.t("Scroll left") + '</span></button><button class="menuslider-button" id="menuslider-next" rel="[2,' + noConflictCounter + ']"><i class="fa fa-angle-right"><span class="element-invisible">' + Drupal.t("Scroll right") + '</span></i></button></div>');
      // calculate automatically the height of the control buttons
      // TODO a CSS solution would also be possible
      // add a gradient background on the main navigation
      // this should be generated by Paddle Themer
      var mainNavColor = $("#main-nav").css("background-color");
      $("#block-paddle-menu-display-first-level .menuslider-controls").css("background", "linear-gradient(to right, rgba(0,0,0,0) 0%," + mainNavColor + " 30%)");
    }

    function checkVisibility(upperThis) {
      var $upperThis = $(upperThis);

      var visibilityGroupId     = 1;
      var totalWidthOfMenuItems = 0;
      // Offset for the padding in a rare case, otherwise the last item is cut-off + buttons
      // innerWidth is the width the div element , that shows the visible part of the menu

      var extraSpace = parseInt($('.menuslider-controls').width()) + parseInt($('.menuslider-controls').css('padding-left')) || 64;
      var availableWidth = innerWidth - extraSpace ;

      $upperThis.find('> li').each(function () {
          itemWidth = parseInt($(this).attr('dynamicwidth'));
          if ((availableWidth - totalWidthOfMenuItems) > itemWidth) {
              // It still fits, so we will add it to this group
              totalWidthOfMenuItems = totalWidthOfMenuItems + itemWidth;
          }
          else {
              // Starting a new group, because this group is better.
              // Also resetting the total width starting with the current itemWidth.
              visibilityGroupId++;
              totalWidthOfMenuItems = itemWidth;
          }

          $(this).attr("visibility", visibilityGroupId);
      });
    }

    function initiate() {

      $(innerContent).each(function () {
        var totalWidth = 0;
        var $upperThis = $(this);

        $upperThis.attr('fladers-nav-id', noConflictCounter).parent().attr('counter', 1);

        $upperThis.find('> li').each(function () {
          var $this = $(this);
          var span = $this.find('> a > span.menu-link-text');
          var font_size = span.css('font-size');
          var font_weight = span.css('font-weight');
          var font_family = span.css('font-family');
          var text_transform = span.css('text-transform');
          // The padding of our menu items is placed on the a tag, instead of on the span.
          var padding = { 'top': $this.find('a').css('padding-top'),
                          'right': $this.find('a').css('padding-right'),
                          'bottom': $this.find('a').css('padding-bottom'),
                          'left' : $this.find('a').css('padding-left')
                        };

          var margin = { 'top': $this.find('a').css('margin-top'),
            'right': $this.find('a').css('margin-right'),
            'bottom': $this.find('a').css('margin-bottom'),
            'left' : $this.find('a').css('margin-left')
          };

          var text_object = measureText(span.text(), font_size, font_weight, font_family, text_transform, padding, margin);
          itemWidth = text_object.width;
          $this.attr('dynamicWidth', itemWidth);
          totalWidth += itemWidth;
        });

        $upperThis.width((totalWidth + 4));

        if ((totalWidth > $upperThis.parent().width())) {
          setControls($upperThis, $(this).attr('fladers-nav-id'));
        }
        checkVisibility($upperThis, noConflictCounter);
        noConflictCounter++;
        $upperThis.attr('totalWidth', totalWidth);
      });
    }

    function resizeContainer() {
      $(innerContent).each(function () {

        $(this).css('left', '0').parent().attr('counter', 1);
        innerWidth = $(this).parent().width();
        checkVisibility(this);
        if (($(this).attr("totalWidth") > innerWidth) && ($(this).parent().find('.menuslider-controls').length === 0)) {
          setControls($(this), $(this).attr('fladers-nav-id'));
        }
        else if (($(this).attr("totalWidth") <= innerWidth) && $(this).parent().find('.menuslider-controls').length === 1) {
            $(this).parent().find('.menuslider-controls').remove();
        }
      });
    }

    /**
     * Measures the dimensions of text by recreating a div with the same style
     * as the element which contains the text, but the text will not be wrapped
     * or cut off.
     *
     * @param {string} pText The actual text we try to measure the width from.
     * @param {string} pFontSize The font size of the element which the text is placed in.
     * @param {string} pFontWeight The font weight of the element which the text is placed in.
     * @param {string} pFontFamily The font family of the element which the text is placed in.
     * @param {string} pTextTransform The text transformation of the element which the text is placed in.
     * @param {string} pPadding The padding of the element which the text is placed in.
     * @param {string} pMargin The margin of the element which the text is placed in.
     * @return {Object} An Object containing the height and width of the text within the same
     * style properties.
     */
    function measureText(pText, pFontSize, pFontWeight, pFontFamily, pTextTransform, pPadding, pMargin) {
      var lDiv = document.createElement('div');

      document.body.appendChild(lDiv);

      lDiv.style.fontFamily = pFontFamily;
      lDiv.style.fontWeight = pFontWeight;
      lDiv.style.fontSize = pFontSize;
      lDiv.style.textTransform = pTextTransform;

      lDiv.style.paddingLeft = pPadding['left'];
      lDiv.style.paddingRight = pPadding['right'];
      lDiv.style.paddingTop = pPadding['top'];
      lDiv.style.paddingBottom = pPadding['bottom'];
      lDiv.style.marginLeft = pMargin['left'];
      lDiv.style.marginRight = pMargin['right'];
      lDiv.style.marginTop = pMargin['top'];
      lDiv.style.marginBottom = pMargin['bottom'];

      lDiv.style.position = "absolute";
      // We do not want the div to be shown in the page.
      lDiv.style.left = -1000;
      lDiv.style.top = -1000;

      lDiv.innerHTML = pText;

      // Margin is not part of the clientWidth so need to be added separately.
      var margin = parseFloat(lDiv.style.marginLeft) + parseFloat(lDiv.style.marginRight);

      var lResult = {
        width: lDiv.clientWidth + margin,
        height: lDiv.clientHeight
      };

      // Remove the div after the measurements have been made.
      document.body.removeChild(lDiv);
      lDiv = null;

      return lResult;
    }

    function slideEvent(slideDirection, classListener) {

      var tmpCounter = parseInt(classListener.attr("counter"));
      var totalWidth = parseInt(classListener.find("> ul").attr("totalWidth"));
      var maxVisibility = classListener.find('> ul > li.last').attr('visibility');
      function getWidth(visibilityNumber) {
        var visibilityWidth = 0;
        var itemWidth = 0;
        $(classListener).find('ul.menu > li[visibility="' + visibilityNumber + '"]').each(function (index) {
          itemWidth = $(this).attr('dynamicwidth');
          visibilityWidth = visibilityWidth + parseInt(itemWidth);
        });
        return visibilityWidth;
      }

      if (slideDirection[1] == 2) {
        if (!(tmpCounter >= maxVisibility)) {
          var visibilityWidth = getWidth(tmpCounter);
          $(classListener).find('ul').first().animate({left: "-=" + visibilityWidth}, 500);
          tmpCounter++;
          classListener.attr("counter",tmpCounter);
        } else {
          // Add a class to indicate that the menu sliding has reached it's
          // right end.
          $('.menuslider-controls').addClass('slider-right-end');
        }

      } else {
        if (!(tmpCounter == 1)) {
          tmpCounter--;
          var visibilityWidth = getWidth(tmpCounter);
          $(classListener).find('ul').first().animate({left: "+=" + visibilityWidth}, 500);
          classListener.attr("counter", tmpCounter);
        }
        if ($('.menuslider-controls').hasClass('slider-right-end')) {
          // Remove the class that indicates that the menu sliding has reached
          // it's right end.
          $('.menuslider-controls').removeClass('slider-right-end');
        }
      }
    }

    $(window).smartresize(resizeContainer);
    $(window).on("load", function () {initiate();});
    $(window).off("click", ".menuslider-button").on("click", ".menuslider-button", function () {
        slideEvent($(this).attr('rel'), $(this).parent().parent());
    });
  };

})(jQuery);

(function($,sr){

  var debounce = function (func, threshold, execAsap) {
      var timeout;

      return function debounced () {
          var obj = this, args = arguments;
          function delayed () {
              if (!execAsap)
                  func.apply(obj, args);
              timeout = null;
          }

          if (timeout)
              clearTimeout(timeout);
          else if (execAsap)
              func.apply(obj, args);

          timeout = setTimeout(delayed, threshold || 100);
      };
  };
  // smartresize
  jQuery.fn[sr] = function(fn){  return fn ? this.bind('resize', debounce(fn)) : this.trigger(sr); };

})(jQuery,'smartresize');

<?php

/**
 * @file
 * Main functions and hook implementations for the Paddle Core module.
 */

include_once 'paddle_core.features.inc';
include_once 'paddle_core.templates.inc';

/**
 * A global constant indicating the maximum length the system should support.
 */
define('PADDLE_CORE_EXTERNAL_URL_MAX_LENGTH', 255);

/**
 * Implements hook_menu_breadcrumb_alter().
 */
function paddle_core_menu_breadcrumb_alter(&$active_trail, $item) {
  global $language_content;
  // Get the current page from the active trail.
  $menu_link = $active_trail[count($active_trail) - 1] ?: array();

  // Create a new trail, but include the home page crumb from the old trail. We
  // could make this configurable in the future.
  $active_trail = array($active_trail[0]);

  // Stop if we don't have a real menu link to work with.
  if (!isset($menu_link['mlid'])) {
    return;
  }

  // Loop over all parents of the menu link. Note that this includes the current
  // menu link itself as well.
  $i = 1;
  do {
    // Don't reload the current page's menu link, as it might turn the access to
    // FALSE for nodes that aren't in an actual menu.
    $mlid = $menu_link['p' . $i++];
    $crumb_link = ($mlid == $menu_link['mlid']) ? $menu_link : menu_link_load($mlid);

    // Make sure the user has access to the link before adding it to the trail.
    if (!empty($crumb_link['access'])) {
      $active_trail[] = $crumb_link;
    }
  } while (!empty($menu_link['p' . $i]));

  // If there is a menu item available which is linked to the current page in the main menu, the
  // menu item should be used. Otherwise the page title will be used as the last
  // breadcrumb trail item.
  $last_position = count($active_trail) - 1;
  $last_page_menu_item = menu_link_load($menu_link['mlid']);
  if (isset($last_page_menu_item) && $last_page_menu_item['menu_name'] == 'main_menu_' . $language_content->language) {
    $active_trail[$last_position] = $last_page_menu_item;
  }
  else {
    $active_trail[$last_position]['href'] = "";
  }

  // Always display a link to the current page by duplicating the last link in
  // the active trail. This means that menu_get_active_breadcrumb() will remove
  // the last link (for the current page), but since it is added once more here,
  // it will appear.
  if (!drupal_is_front_page()) {
    $end = end($active_trail);
    if ($item['href'] == $end['href']) {
      $active_trail[] = $end;
    }
  }
}

/**
 * Implements hook_paddle_menu_display_menu_items_alter().
 */
function paddle_core_paddle_menu_display_menu_items_alter(&$items, $menu_display) {
  // Only add extra classes to the management menu for now.
  if ($menu_display->menu_name != 'management') {
    return;
  }

  foreach ($items as $mlid => $item) {
    // Generate a class for the menu item based on its path.
    $path = $item['link'];
    $item_class = drupal_html_class('ml-path-' . $path);

    // Add the class to the menu item's list item.
    $li_class = $item['li_class'];
    paddle_menu_display_add_class($li_class, $item_class);
    $items[$mlid]['li_class'] = $li_class;
  }
}

/**
 * Implements hook_init().
 *
 * Performs the following actions:
 * - Sets the active menu according to the current path.
 * - Shows a message on node edit pages to inform about a conflict between the
 *   URL alias and a menu path generated by Paddle Path By Menu.
 */
function paddle_core_init() {
  global $language;

  // Tracks back-end users.
  if (path_is_admin(current_path())) {
    if (variable_get('paddle_backend_tracking_id', '')) {
      $tracking_id = variable_get('paddle_backend_tracking_id', '');
      paddle_core_add_analytics_tracker($tracking_id);
    }
  }
  // Tracks front-end users.
  elseif (variable_get('paddle_frontend_tracking_id', '')) {
    $tracking_id = variable_get('paddle_frontend_tracking_id', '');
    paddle_core_add_analytics_tracker($tracking_id);
  }

  $active_menus = menu_get_active_menu_names();

  // Find the main menu containing a link for the current page.
  $menu_item = menu_get_item();
  if (!$menu_item && module_exists('paddle_path_by_menu')) {
    // This happens when we are on path resolved by Paddle Path By Menu module.
    $path_info = paddle_path_by_menu_resolve($_GET['q']);
    $menu_item = menu_get_item($path_info['link_path']);
    global $language_content;

    $menu_names = variable_get('paddle_path_by_menu_menus', menu_get_names());
    if (in_array('main_menu_' . $language_content->language, $menu_names)) {
      array_unshift($active_menus, 'main_menu_' . $language_content->language);
      menu_set_active_menu_names($active_menus);
      return;
    }
  }
  else {
    // In case we are on the real Drupal alias like 'content/some-title'.
    $result = db_query("SELECT mlid, menu_name FROM {menu_links} WHERE link_path = :menu_item AND menu_name LIKE :menu_name", array(
      ':menu_item' => $menu_item['href'],
      ':menu_name' => '%main_menu%',
    ));

    $menu_list = paddle_menu_manager_get_menus();
    foreach ($result as $menu_link) {
      // Set the preferred menu for the breadcrumbs.
      if (array_key_exists($menu_link->menu_name, $menu_list)) {
        array_unshift($active_menus, $menu_link->menu_name);
        break;
      }
    }
  }
  menu_set_active_menu_names($active_menus);

  // Display a warning to the user when the node that is being edited or viewed
  // in the administrative node view has a URL alias or path generated by
  // Paddle Path By Menu that conflicts with other nodes.
  if ($menu_item['path'] == 'node/%/edit' && isset($menu_item['page_arguments'][0]->nid) ||
    $menu_item['path'] == 'admin/content_manager/node/%/view' && isset($menu_item['page_arguments'][1]->data->nid)
  ) {
    // Retrieve the node id from either the CTools context or directly from the
    // page arguments.
    $nid = $menu_item['path'] == 'node/%/edit' ? $menu_item['page_arguments'][0]->nid : $menu_item['page_arguments'][1]->data->nid;
    // Check if the node's URL alias conflicts with another node's
    // Paddle Path By Menu URL.
    if (($alias = drupal_lookup_path('alias', 'node/' . $nid)) && ($path_info = paddle_path_by_menu_resolve($alias)) && $path_info['link_path'] != 'node/' . $nid) {
      $conflicting_menu_item = menu_get_item($path_info['link_path']);
      drupal_set_message(t('The URL alias of this page conflicts with the following page: <em>"!page"</em>. Please choose a different URL alias before publishing the page to avoid problems.', array(
        '!page' => l($conflicting_menu_item['title'], $path_info['link_path']),
      )), 'warning');
    }
    // Check if the node's Paddle Path By Menu URL conflicts with another node's
    // URL alias.
    $menu = paddle_menu_manager_get_menu('main_menu_en');
    $menu_link = menu_link_get_preferred('node/' . $nid, $menu['menu_name']);
    $alias = path_load(array('alias' => paddle_path_by_menu_get_menu_path($menu_link)));
    if ($alias && $alias['source'] != 'node/' . $nid) {
      $conflicting_menu_item = menu_get_item($alias['source']);
      drupal_set_message(t('The menu title of this page conflicts with the following page: <em>"!page"</em>. Please choose a different menu title before publishing the page to avoid problems.', array(
        '!page' => l($conflicting_menu_item['title'], $alias['source']),
      )), 'warning');
    }
  }
}

/**
 * Adds the Google Analytics tracker JS code to the page based on a tracker ID.
 *
 * @param string $tracking_id
 *   The Google Analytics tracker ID.
 */
function paddle_core_add_analytics_tracker($tracking_id) {
  if (!empty($tracking_id)) {
    $tracking_code = '(function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","//www.google-analytics.com/analytics.js","ga");ga("create", "%ga_code", "auto");ga("set", "anonymizeIp", true);ga("send", "pageview");';
    $code = str_replace('%ga_code', $tracking_id, $tracking_code);
    drupal_add_js($code, array('scope' => 'header', 'type' => 'inline'));
  }
}

/**
 * Implements hook_menu_alter().
 */
function paddle_core_menu_alter(&$items) {
  // Users visiting the Menu Manager overview should be redirected.
  $items['admin/structure/menu_manager']['page callback'] = 'paddle_core_menu_manager_overview';

  // Users visiting the structure page, should be redirected to the menu
  // manager. It should only be visible to people that are allowed to, instead
  // of the overarching 'access administration pages' that Core normally uses.
  $items['admin/structure']['page callback'] = 'paddle_core_admin_structure_redirect';
  $items['admin/structure']['access arguments'] = array('access structure menu');

  // Normally these items are protected by the 'access administration pages'
  // permission. However, we do not want our editors to be able to access them.
  $items['admin/tasks']['access arguments'] = array('administer site configuration');
  $items['admin/index']['access arguments'] = array('administer site configuration');
  $items['admin/config']['access arguments'] = array('administer site configuration');

  // We change the CKEditor autocomplete callback to behave as the menu item
  // form internal item autocomplete.
  $items['ckeditor_link/autocomplete']['page callback'] = 'paddle_menu_manager_internal_link_autocomplete_callback';
  $items['ckeditor_link/autocomplete']['file path'] = drupal_get_path('module', 'paddle_menu_manager');
  $items['ckeditor_link/autocomplete']['file'] = 'paddle_menu_manager.module';

  // Remove access from the standard frontpage.
  $items['node']['access callback'] = FALSE;

  // Remove access from the standard Drupal "Node add" and "Add Landing page"
  // pages.
  $items['node/add']['access callback'] = FALSE;
  foreach (node_type_get_names() as $type => $name) {
    $items['node/add/' . str_replace('_', '-', $type)]['access callback'] = FALSE;
  }
}

/**
 * Page callback; overrides paddle_menu_manager_overview().
 */
function paddle_core_menu_manager_overview() {
  // The user should be redirected to the edit screen of the first menu item
  // when visiting the Menu Manager overview.
  $query = db_select('i18n_translation_set', 'ts');
  $query->addExpression('MIN(ts.tsid)', 'tsid');
  $query->condition('ts.type', 'paddle_menu_manager');
  $res = $query->execute()->fetchAll();
  global $language_content;

  if (is_numeric($res[0]->tsid) && $res[0]->tsid > 0) {
    drupal_goto('admin/structure/menu_manager/' . $res[0]->tsid);
  }
  else {
    ctools_include('modal');
    ctools_include('ajax');
    ctools_modal_add_js();
    $link = ctools_modal_text_button(t('Create Menu'), 'admin/structure/menu_manager/nojs/add', t('Create a new menu.'));
    return t('No menus have been created yet. !link', array('!link' => $link));
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * This targets all node forms for all content types.
 */
function paddle_core_form_node_form_alter(&$form, &$form_state, $form_id) {
  // Replace the standard Core menus with Paddle menus.
  _paddle_core_form_node_form_alter_menu($form, $form_state, $form_id);

  // Allow to alter the form after it is completely built.
  $form['#after_build'][] = 'paddle_core_form_node_form_after_build';

  // Add our javascript functionality to the node forms.
  $form['#attached']['js'][] = drupal_get_path('module', 'paddle_core') . '/js/node_form.js';

  // Add an extra validate handler for the path alias.
  $form['#validate'][] = 'paddle_core_validate_path_alias';

  // Disable wysiwyg editor (CKEditor) for summary node field.
  if (isset($form['body'][LANGUAGE_NONE][0]['summary'])) {
    $form['body'][LANGUAGE_NONE][0]['summary']['#wysiwyg'] = FALSE;
  }

  // Change the ordering inside the paddle tags field.
  if (!empty($form['field_paddle_tags'])) {
    $form['field_paddle_tags'][LANGUAGE_NONE]['field_terms']['#weight'] = 15;
    $form['field_paddle_tags'][LANGUAGE_NONE]['term_entry']['#weight'] = 5;
    $form['field_paddle_tags'][LANGUAGE_NONE]['add_button']['#weight'] = 10;
  }
}

/**
 * Form #after_build callback for paddle_core_form_node_form_alter().
 */
function paddle_core_form_node_form_after_build($form, &$form_state) {
  // Streamline the scheduler options.
  if (!empty($form['scheduler_settings'])) {
    // Remove the "Date" and "Time" labels.
    $form['scheduler_settings']['publish_on']['date']['#title_display'] = 'invisible';
    $form['scheduler_settings']['publish_on']['time']['#title_display'] = 'invisible';
    $form['scheduler_settings']['unpublish_on']['date']['#title_display'] = 'invisible';
    $form['scheduler_settings']['unpublish_on']['time']['#title_display'] = 'invisible';

    // Remove the example date and time format descriptions and replace them
    // with greyed out placeholders.
    $placeholder_date = format_date(REQUEST_TIME, 'custom', variable_get('scheduler_date_only_format', 'Y-m-d'));
    $placeholder_time = format_date(REQUEST_TIME, 'custom', 'H:i:s');
    $form['scheduler_settings']['publish_on']['date']['#attributes']['placeholder'] = $placeholder_date;
    $form['scheduler_settings']['publish_on']['time']['#attributes']['placeholder'] = $placeholder_time;
    $form['scheduler_settings']['unpublish_on']['date']['#attributes']['placeholder'] = $placeholder_date;
    $form['scheduler_settings']['unpublish_on']['time']['#attributes']['placeholder'] = $placeholder_time;
    $form['scheduler_settings']['publish_on']['date']['#description'] = '';
    $form['scheduler_settings']['publish_on']['time']['#description'] = '';
    $form['scheduler_settings']['unpublish_on']['date']['#description'] = '';
    $form['scheduler_settings']['unpublish_on']['time']['#description'] = '';

    // Remove the help texts.
    $form['scheduler_settings']['publish_on']['#description'] = '';
    $form['scheduler_settings']['unpublish_on']['#description'] = '';
  }
  return $form;
}

/**
 * Implements hook_node_presave().
 *
 * We try to hide the distinction between "Scheduled" and "Published" nodes for
 * the end user. Here we make sure that when a user saves content the moderation
 * and publication states are always valid, regardless of which moderation state
 * has been chosen.
 * - If the user edits content that was already scheduled, but he or she may
 *   not schedule, force the content to be draft.
 * - If the user "schedules" content but there is no publication date set, force
 *   the content to be published.
 * - If the user "publishes" content but there is a publication date, schedule
 *   the content instead.
 */
function paddle_core_node_presave($node) {
  if (workbench_moderation_node_type_moderated($node->type)
    && variable_get('scheduler_publish_enable_' . $node->type, FALSE)
    && !empty($node->workbench_moderation_state_new)
  ) {
    if ($node->workbench_moderation_state_new == 'scheduled') {
      if ($node->workbench_moderation_state_new == $node->workbench_moderation_state_current
        && !user_access('moderate content from scheduled to published')
      ) {
        // Set scheduled content to draft if user doesn't have publish
        // permission.
        $node->workbench_moderation_state_new = 'draft';
      }
      elseif (empty($node->publish_on)) {
        // Publish scheduled content that does not have a publication date.
        $node->workbench_moderation_state_new = 'published';
        $node->status = 1;
        $node->publish_on = 0;
        drupal_set_message(t('The content has been published.'), 'status');
      }
    }
    // Schedule content that has a publication date but has its moderation state
    // set to "Published".
    if ($node->workbench_moderation_state_new == 'published' && !empty($node->publish_on)) {
      $node->workbench_moderation_state_new = 'scheduled';
      $node->status = 0;
      drupal_set_message(t('The content has been scheduled.'), 'status');
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters the simplified Landing Page node add/edit form.
 */
function paddle_core_form_paddle_landing_page_add_edit_form_alter(&$form, &$form_state, $form_id) {
  // Replace the standard Core menus with Paddle menus.
  _paddle_core_form_node_form_alter_menu($form, $form_state, $form_id);
}

/**
 * Alters the menu options of standard node add/edit forms and their variants.
 *
 * Replace the standard Core menus with Paddle menus.
 *
 * This function is intended to be called from a hook_form_alter(), so that the
 * code can be reused for standard node add/edit forms as well as the simplified
 * derived forms that are intended to be shown in modal dialogs.
 */
function _paddle_core_form_node_form_alter_menu(&$form, &$form_state, $form_id) {
  $link = $form['#node']->menu;
  $type = $form['#node']->type;

  // Add support for the Paddle Menu Manager.
  $form['menu']['#access'] = user_access('manage paddle_menu_manager') || $form['menu']['#access'];

  // Enable check box if menu link exists.
  $form['menu']['enabled']['#default_value'] = (int) (bool) $link['mlid'];

  // Override available menus.
  $available_menus = paddle_menu_manager_get_menus($form['#node']->language);
  $menus = array();
  foreach ($available_menus as $menu) {
    $menus[$menu['menu_name']] = $menu['title'];
  }

  $options = menu_parent_options($menus, $link['mlid'] ? $link : NULL);

  // If no possible parent menu items were found, there is nothing to display.
  if (empty($options)) {
    unset($form['menu']);
  }
  else {
    // Default menu link.
    $default = ($link['mlid'] ? $link['menu_name'] . ':' . $link['plid'] : 'main_menu_' . $form['#node']->language . ':0');

    $form['menu']['link']['parent']['#options'] = $options;
    $form['menu']['link']['parent']['#default_value'] = $default;
  }
}

/**
 * Implements hook_node_prepare().
 *
 * Core menu module restricts menu_link loading from the registered menus per
 * content type only. We want all paddle menus to be available by default,
 * regardless if they are enabled for this content type.
 */
function paddle_core_node_prepare($node) {

  // Locate menu item if none has been assigned.
  if (empty($node->menu['mlid'])) {

    $language = !empty($node->language) ? $node->language : NULL;
    $available_menus = paddle_menu_manager_get_menus($language);
    $menus = array();
    foreach ($available_menus as $menu) {
      $menus[$menu['menu_name']] = $menu['menu_name'];
    }

    $item = array();
    if (isset($node->nid)) {
      $mlid = FALSE;
      // Check all allowed menus if a link does not exist in the default menu.
      if (!empty($menus)) {
        $mlid = db_query_range("SELECT mlid FROM {menu_links} WHERE link_path = :path AND module = 'menu' AND menu_name IN (:type_menus) ORDER BY mlid ASC", 0, 1, array(
          ':path' => 'node/' . $node->nid,
          ':type_menus' => array_values($menus),
        ))->fetchField();
      }
      if ($mlid) {
        $item = menu_link_load($mlid);
        // Merge values.
        $node->menu = $item + $node->menu;
        // Find the depth limit for the parent select.
        if (!isset($node->menu['parent_depth_limit'])) {
          $node->menu['parent_depth_limit'] = _menu_parent_depth_limit($node->menu);
        }
      }
    }
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function paddle_core_module_implements_alter(&$implementations, $hook) {
  // Our hook_node_presave() implementation modifies the moderation states
  // according to the scheduling status. It should run after Scheduler and
  // before Workbench Moderation.
  if ($hook == 'node_presave') {
    // Move our implementation to the end of the list. module_implements()
    // iterates through $implementations with a foreach loop which PHP iterates
    // in the order that the items were added, so to move an item to the end of
    // the array, we remove it and then add it.
    $implementation = $implementations['paddle_core'];
    unset($implementations['paddle_core']);
    $implementations['paddle_core'] = $implementation;

    // Now move Workbench Moderation to the end of the list.
    $implementation = $implementations['workbench_moderation'];
    unset($implementations['workbench_moderation']);
    $implementations['workbench_moderation'] = $implementation;
  }

  // Our implementation of hook_menu_breadcrumb_alter should come at the end so
  // we have full control.
  if ($hook == 'menu_breadcrumb_alter') {
    $group = $implementations['paddle_core'];
    unset($implementations['paddle_core']);
    $implementations['paddle_core'] = $group;
  }
}

/**
 * Implements hook_workbench_moderation_state_transition_button_labels_alter().
 */
function paddle_core_workbench_moderation_state_transition_button_labels_alter(&$transitions) {
  // Please note that the labels for 'scheduled' and 'published' content are
  // identical. We aim to remove this distinction for our users.
  $replacements = array(
    'to_check' => t('To editor'),
    'scheduled' => t('Publish'),
    'needs_review' => t('To chief editor'),
    'offline' => t('Unpublish'),
    workbench_moderation_state_published() => t('Publish'),
  );

  foreach ($transitions as $transition) {
    if (array_key_exists($transition->to_name, $replacements)) {
      $transition->label = $replacements[$transition->to_name];
    }
  }
}

/**
 * Implements hook_workbench_moderation_states_next_alter().
 *
 * Do not allow to transition to Published state for content that is scheduled
 * for publication, or to Scheduled state when there is no publication date.
 */
function paddle_core_workbench_moderation_states_next_alter(&$states, $current_state, $context) {
  // Check if the user is creating or editing nodes. If this is the case, we
  // simply disable the "Schedule" option. The user can click on "Publish" since
  // the moderation state will be fixed in paddle_core_node_presave() anyway.
  // We use the statically cached menu item instead of calling menu_get_item()
  // to avoid an endless loop if the menu router is determining access to a page
  // that depends on the next moderation states. It does not matter if the menu
  // router can bypass this since we are just removing these transitions for
  // usability reasons.
  $router_items = drupal_static('menu_get_item');
  if (!empty($router_items[$_GET['q']])) {
    $menu_item = $router_items[$_GET['q']];
    if ($menu_item['path'] == 'node/%/edit' || strpos($menu_item['path'], 'node/add/') === 0) {
      if (array_key_exists('scheduled', $states)) {
        unset($states['scheduled']);
      }
    }
    else {
      // Disable the "Publish" option if the node is scheduled in the future.
      if (array_key_exists('published', $states) && !empty($context['node']->publish_on) && $context['node']->publish_on > REQUEST_TIME) {
        unset($states['published']);
      }
      // Disable the "Schedule" option if the node is not scheduled, or is
      // scheduled in the past.
      elseif (array_key_exists('scheduled', $states) && (empty($context['node']->publish_on) || $context['node']->publish_on < REQUEST_TIME)) {
        unset($states['scheduled']);
      }
    }
  }
}

/**
 * Implements hook_workbench_moderation_transition().
 */
function paddle_core_workbench_moderation_transition($node, $previous_state, $new_state) {
  // Unpublish nodes that are moderated to the "Offline" state.
  // @see workbench_moderation_node_unpublish_form_submit()
  if ($new_state == 'offline') {
    // Remove the moderation record's "published" flag.
    if (!empty($node->workbench_moderation['published']->hid)) {
      $query = db_update('workbench_moderation_node_history')
        ->condition('hid', $node->workbench_moderation['published']->hid)
        ->fields(array('published' => 0))
        ->execute();
    }

    // Make sure the 'current' revision is the 'live' revision.
    $live_revision = workbench_moderation_node_current_load($node);
    $live_revision->status = 0;
    $live_revision->revision = 0;
    $live_revision->workbench_moderation['updating_live_revision'] = TRUE;
    node_save($live_revision);
  }

  if ($new_state == 'scheduled' && $new_state != $previous_state) {
    $date_format = variable_get('scheduler_date_format', SCHEDULER_DATE_FORMAT);
    drupal_set_message(
      t(
        'This post is unpublished and will be published @publish_time.',
        array(
          '@publish_time' => format_date(
            $node->publish_on,
            'custom',
            $date_format
          ),
        )
      ),
      'status',
      FALSE
    );
  }
}

/**
 * Implements hook_menu().
 */
function paddle_core_menu() {
  $items = array();

  $items['admin/site-settings'] = array(
    'title' => 'Site settings',
    'access arguments' => array('paddle_core configure site settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('paddle_core_site_settings_form'),
    'type' => MENU_CALLBACK,
    'localize' => TRUE,
    'file' => 'paddle_core.admin.inc',
  );

  $items['paddle_site_settings_autocomplete'] = array(
    'page callback' => 'paddle_site_settings_autocomplete',
    'type' => MENU_CALLBACK,
    'access arguments' => array('paddle_core configure site settings'),
  );

  $items['placeholder'] = array(
    'page callback' => 'paddle_core_placeholder',
    'type' => MENU_NORMAL_ITEM,
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Provides a placeholder for the front page.
 */
function paddle_core_placeholder() {
  drupal_set_title(t('Welcome to @site-name', array('@site-name' => variable_get('site_name', 'Drupal'))), PASS_THROUGH);
  $default_message = '<p>' . t('No front page content has been created yet.') . '</p>';

  $build['default_message'] = array(
    '#markup' => $default_message,
    '#prefix' => '<div id="first-time">',
    '#suffix' => '</div>',
  );

  return $build;
}

/**
 * Implements hook admin_paths().
 */
function paddle_core_admin_paths() {
  $paths = array(
    'panels/ajax/*' => TRUE,
    'toboggan/denied' => TRUE,
  );

  return $paths;
}

/**
 * Implements hook_permission().
 */
function paddle_core_permission() {
  return array(
    'admin_structure' => array(
      'title' => t('Access the original administer structure page'),
    ),
    'paddle_core configure site settings' => array(
      'title' => t('Manage Paddle configuration'),
    ),
    'access structure menu' => array(
      'title' => t('Access the structure menu'),
    ),
  );
}

/**
 * Conditionally redirects users to the menu manager.
 *
 * Users with the 'admin_structure' permission will get the original
 * admin/structure page served, others will be redirected to the menu
 * manager instead.
 */
function paddle_core_admin_structure_redirect() {
  if (user_access('admin_structure')) {
    return system_admin_menu_block_page();
  }
  else {
    drupal_goto('admin/structure/menu_manager');
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Attach the js file for the autocomplete.
 */
function paddle_core_form_paddle_menu_manager_menu_item_form_alter(&$form, &$form_state, $form_id) {
  $form['#attached']['js'][] = array(
    'data' => drupal_get_path('module', 'paddle_core') . '/js/autocomplete_keyboard_select.js',
    'type' => 'file',
  );
}

/**
 * Implements hook_paddle_menu_display_block_display_alter().
 */
function paddle_core_paddle_menu_display_block_display_alter(&$menu_display) {
  // Show the requested menu in the current content language.
  $menu = paddle_menu_manager_get_menu($menu_display->menu_name);
  $menu_display->menu_name = $menu['menu_name'];

  // Change the depth of the top menu according to which option has been chosen
  // in the theme settings: no_dropdown, simple_dropdown or mega_dropdown.
  if ($menu_display->name == 'first_level') {
    $navigation_behaviour = variable_get('paddle_core_theme_grid_navigation_behaviour', -1);
    if ($navigation_behaviour) {
      $menu_to_depth = -1;
      switch ($navigation_behaviour) {
        case 'no_dropdown':
          $menu_to_depth = 1;
          break;

        case 'simple_dropdown':
          $menu_to_depth = 2;
          break;

        case 'mega_dropdown':
          $menu_to_depth = 3;
          break;
      }
      // We want to change it only if this value have been set.
      if ($menu_to_depth > 0) {
        $menu_display->to_level = $menu_to_depth;
        // Add a class indicating the depth for styling purposes.
        if (strlen($menu_display->div_class) > 0) {
          $menu_display->div_class .= ' ';
        }
        $menu_display->div_class .= 'menu-depth-' . $menu_to_depth;
      }
    }
  }

  // Change the number of levels displayed in the footer menu according to the
  // thin/fat footer settings.
  if ($menu_display->name == 'footer_menu') {
    $footer_style = variable_get('paddle_core_footer_footer_style', 'no_footer');
    if ($footer_style) {
      $menu_to_depth = -1;
      if ($footer_style == 'fat_footer') {
        $menu_to_depth = 2;
      }
      // We want to change it only if this value have been set.
      if ($menu_to_depth > 0) {
        $menu_display->to_level = $menu_to_depth;
        // Add a class indicating the depth for styling purposes.
        if (strlen($menu_display->div_class) > 0) {
          $menu_display->div_class .= ' ';
        }
        $menu_display->div_class .= 'menu-depth-' . $menu_to_depth;
      }
    }
  }

  // Allow to hide the "Level below" menu display on pages. On pages the editors
  // have the possibility to add their own navigation panes, in which case the
  // menu is no longer needed.
  $node = menu_get_object();
  if ($menu_display->name == 'current_level_plus_one') {
    if ($node && isset($node->type)) {
      $show_next_level = field_get_items('node', $node, 'field_paddle_show_next_level');
      if ($show_next_level[0]['value'] != 1) {
        // Set the name to '' to avoid displaying the menu display.
        $menu_display->menu_name = '';
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the "Custom content" plugin:
 * - Do not show the text format settings.
 * - Resize the modal window after the wysiwyg is loaded.
 */
function paddle_core_form_paddle_panes_free_content_content_type_edit_form_alter(&$form, &$form_state, $form_id) {
  // Hide the text format settings.
  $form['#after_build'] = array(
    'paddle_core_free_content_content_type_after_build',
  );
}

/**
 * After-build function of the paddle landing page free content form.
 *
 * @see paddle_core_form_paddle_landing_page_free_content_type_edit_form_alter()
 */
function paddle_core_free_content_content_type_after_build($form, $form_state) {
  // Hide the text format settings.
  $form['pane_settings']['section_body']['free_content']['format']['#access'] = FALSE;
  return $form;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the Paddle Themer Styles Edit Wizard form:
 * - Change the vertical tabs into an accordeon.
 *
 * @see paddle_themer_styles_edit_wizard_form()
 */
function paddle_core_form_paddle_themer_theme_edit_form_alter(&$form, &$form_state) {
  // Disable the vertical tabs.
  unset($form['style_sets']['#type']);

  // The first style set should be expanded, the others folded.
  $folded = '';

  // Loop through the elements, and transform into an accordeon.
  if (isset($form['style_sets'])) {
    foreach (element_children($form['style_sets']) as $child) {
      if ($form['style_sets'][$child]['#type'] == 'fieldset' && !empty($form['style_sets'][$child]['#group']) && $form['style_sets'][$child]['#group'] == 'style_sets') {
        $form['style_sets'][$child]['#type'] = 'container';
        $form['style_sets'][$child]['#attributes']['class'][] = 'pane-content';
        $form['style_sets'][$child]['#prefix'] = '<div class="clearfix foldable' . $folded . '"><h2 class="pane-title">' . $form['style_sets'][$child]['#title'] . '</h2>';
        $form['style_sets'][$child]['#suffix'] = '</div>';
        $folded = ' folded';
      }
    }
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function paddle_core_ctools_plugin_directory($module, $plugin) {
  $types = array(
    'ctools:content_types',
    'paddle_style:paddle_style',
  );
  if (in_array("$module:$plugin", $types)) {
    return "plugins/$plugin";
  }
}

/**
 * Autocomplete callback for nodes by title or real path.
 *
 * @param string $string
 *   The string that will be searched.
 * @param int $nid
 *   When the user searches for "node/<nid>" this will hold the nid.
 *
 * Searches for a node by title or real path, but then identifies it by nid,
 * so the actual returned value can be used later by the form.
 *
 * The returned $matches array has
 * - key: The title, with the identifying node path in brackets, like
 *     "Some node title (node/444)"
 * - value: the title which will be displayed in the autocompleted dropdown.
 */
function paddle_site_settings_autocomplete($string = "", $nid = 0) {
  global $language_content;
  $results = array();
  if ($string) {
    $query = db_select('node', 'n');
    $query->join('workbench_moderation_node_history', 'wmh', 'wmh.nid = n.nid AND wmh.vid = n.vid');
    $query->fields('n', array('nid', 'title'))
      ->condition('wmh.state', 'archived', '<>')
      ->condition('wmh.is_current', 1, '=')
      ->condition('language', $language_content->language)
      ->addTag('node_access');

    if ($string == 'node' && is_numeric($nid) && $nid !== 0) {
      // The search string is a node path.
      $query->condition('n.nid', $nid, '=');
    }
    elseif ($string != 'node') {
      // The search string is a title or something else.
      $query->condition('title', '%' . db_like(implode('/', func_get_args())) . '%', 'LIKE');
    }
    // If neither is true we basically show the first 10 nodes we can find.
    $query->range(0, 10);
    $result = $query->execute();
    foreach ($result as $node) {
      $results[check_plain($node->title) . " (node/$node->nid)"] = check_plain($node->title) . " (node/$node->nid)";
    }
  }

  drupal_json_output($results);
}

/**
 * Implements hook_apps_servers_info().
 */
function paddle_core_apps_servers_info() {
  return array(
    'paddle_apps' => array(
      'title' => t('Paddle Apps'),
      'description' => t('Apps from the paddle server.'),
      'manifest' => variable_get('paddle_core_apps_server_url', 'http://store.kanooh.be/app/query/Production'),
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add JS file to handle keyboard select from the node autocomplete dropdown.
 */
function paddle_core_form_paddle_panes_node_content_content_type_edit_form_alter(&$form, &$form_state, $form_id) {
  $form['#attached']['js'][] = array(
    'data' => drupal_get_path('module', 'paddle_core') . '/js/autocomplete_keyboard_select.js',
    'type' => 'file',
  );
}

/**
 * Implements hook_paddle_panels_renderer_pane_styles().
 */
function paddle_core_paddle_panels_renderer_pane_styles($pane) {
  return array(
    'color_subpalettes' => array(
      'plugin' => 'color_subpalettes',
      'title' => t('Color subpalette'),
      'default_values' => array('paddle_color_subpalette' => 0),
    ),
  );
}

/**
 * Validate handler for the path alias of nodes.
 */
function paddle_core_validate_path_alias($form, &$form_state) {
  // Check in menu_router if the path is a system path.
  $routes = db_select('menu_router', 'mr')
    ->fields('mr', array('path'))
    ->condition('path', $form_state['values']['path']['alias'], '=');

  // Check in the url_alias if the path is a source path of a node, etc.
  $sources = db_select('url_alias', 'ur')
    ->fields('ur', array('source'))
    ->condition('source', $form_state['values']['path']['alias'], '=');

  // Union the queries to only execute 1 query on the database.
  $result = $routes->union($sources)
    ->execute()
    ->fetchAll();

  if (!empty($result)) {
    form_set_error('path][alias', t('The alias is already in use.'));
  }
}

/**
 * Implements hook_panelizer_pre_render_alter().
 *
 * - Add Paddle IPE specific javascript setting.
 * - Don't use Paddle IPE on node view.
 */
function paddle_core_panelizer_pre_render_alter($panelizer, $display, $entity) {
  if (in_array($panelizer->pipeline, array(
    'paddle_landing_page',
    'paddle_content_region'
  ))) {
    $menu = menu_get_item();
    $admin_node_view_paths = array('admin/content_manager/node/%/view');
    $node_view_paths = array(
      // Current version.
      'node/%',
      // Revision version.
      'node/%/draft',
    );
    if (in_array($menu['path'], $admin_node_view_paths)) {
      $panelizer->pipeline = 'paddle_admin_node_view';
    }
    elseif (in_array($menu['path'], $node_view_paths)) {
      // Don't show Paddle IPE on node views.
      $panelizer->pipeline = 'paddle_standard_renderer';
    }
    else {
      // By default, don't redirect after successful ajax call.
      $js_settings = array(
        'paddle_panels_renderer_redirect_after_successful_ajax_call' => FALSE,
      );
      drupal_add_js($js_settings, 'setting');
    }
  }
}

/**
 * Implements hook_date_format_types().
 */
function paddle_core_date_format_types() {
  return array(
    'paddle_core_date_long' => t('Long date'),
    'paddle_core_date_medium' => t('Medium date'),
    'paddle_core_date_short' => t('Short date'),
  );
}

/**
 * Implements hook_date_formats().
 */
function paddle_core_date_formats() {
  return array(
    array(
      'type' => 'paddle_core_date_long',
      'format' => 'l, F j, Y',
      'locales' => array('en'),
    ),
    array(
      'type' => 'paddle_core_date_long',
      'format' => 'l j F Y',
      'locales' => array('nl'),
    ),
    array(
      'type' => 'paddle_core_date_medium',
      'format' => 'F j, Y',
      'locales' => array('en'),
    ),
    array(
      'type' => 'paddle_core_date_medium',
      'format' => 'j F Y',
      'locales' => array('nl'),
    ),
    array(
      'type' => 'paddle_core_date_short',
      'format' => 'Y/m/d',
      'locales' => array('en'),
    ),
    array(
      'type' => 'paddle_core_date_short',
      'format' => 'd-m-Y',
      'locales' => array('nl'),
    ),
  );
}

/**
 * Get the available search engines.
 *
 * @return array
 *   An array with info on available search engines, keyed by their machine
 *   names.
 */
function paddle_core_get_search_engines() {
  $engines = array();
  foreach (module_implements('paddle_search_engines') as $module) {
    $function = "{$module}_paddle_search_engines";
    $module_engines = $function();

    // Add the 'owning' module name to each engine info array, so
    // hooks/callbacks implemented by the module can be called later on.
    foreach ($module_engines as &$engine) {
      $engine['module'] = $module;

      // Engines are by default disabled, and take the same text as the label,
      // unless otherwise indicated by the delivering hook.
      $engine += array(
        'enabled' => FALSE,
        'text' => $engine['label'],
      );
    }

    $engines += $module_engines;
  }

  // Sort the engines by weight.
  uasort($engines, 'drupal_sort_weight');

  // Default text and default enabled state can be overridden by variables.
  foreach ($engines as $engine_name => &$engine_info) {
    foreach (array('enabled', 'text') as $property) {
      $variable_name = 'paddle_search_' . $engine_name . '_' . $property;
      $engine_info[$property] = variable_get($variable_name, $engine_info[$property]);
    }
  }

  // If there is only one engine, it should always be enabled no matter what its
  // default state or variable-overridden state is.
  if (count($engines) == 1) {
    reset($engines);
    $engine_name = key($engines);
    $engines[$engine_name]['enabled'] = TRUE;
  }

  return $engines;
}

/**
 * Get the enabled search engines.
 *
 * @return array
 *   An array with info on enabled search engines, keyed by their machine
 *   names.
 */
function paddle_core_get_enabled_search_engines() {
  $engines = paddle_core_get_search_engines();

  $enabled_engines = array();
  foreach ($engines as $engine_name => $engine_info) {
    if ($engine_info['enabled']) {
      $enabled_engines[$engine_name] = $engine_info;
    }
  }
  return $enabled_engines;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function paddle_core_form_search_api_page_search_form_alter(&$form, &$form_state) {
  $enabled_engines = paddle_core_get_enabled_search_engines();

  // If multiple search engines are enabled, we should give the user the choice
  // which search engine he wants to use.
  if (count($enabled_engines) > 1) {
    $options = array();

    foreach ($enabled_engines as $engine_name => $engine_info) {
      $options[$engine_name] = $engine_info['text'];
    }

    // Do not use a form token, as this form will be cached inside a block.
    unset($form['#token']);
    unset($form['form_token']);

    $form['search_method'] = array(
      '#type' => 'radios',
      // For the moment the internal site search will be the hardcoded default.
      // This might be made configurable and/or bound to the user session in the
      // future.
      // @see https://one-agency.atlassian.net/browse/KANWEBS-2097
      '#default_value' => 'default_search',
      '#options' => $options,
    );
  }
  // If only 1 search engine is enabled, this is the default search that will be
  // used on the website.
  elseif (count($enabled_engines) == 1) {
    reset($enabled_engines);
    $engine_name = key($enabled_engines);
    $form['search_method'] = array(
      '#type' => 'hidden',
      '#value' => $engine_name,
    );
  }

  unset($form['#submit']);
  $form['#submit'][] = 'paddle_core_search_submit';
}

/**
 * Submit handler for the search form.
 *
 * @see search_api_page_search_form_submit()
 */
function paddle_core_search_submit($form, &$form_state) {
  if (!empty($form_state['values']['search_method'])) {
    $engine_name = $form_state['values']['search_method'];
    $search_engines = paddle_core_get_enabled_search_engines();

    if (isset($search_engines[$engine_name])) {
      $search_engine_info = $search_engines[$engine_name];

      $owning_module = $search_engine_info['module'];

      // We can not pass the form_state variable by reference in module_invoke.
      // Therefore we just call the submit callback directly.
      $submit_callback = "{$owning_module}_paddle_search_{$engine_name}_form_submit";

      if (function_exists($submit_callback)) {
        $submit_callback($form, $form_state);
      }
    }
  }
}

/**
 * Get the available menu styles.
 *
 * @return array
 *   An array with info on available menu styles, keyed by their machine
 *   names.
 */
function paddle_core_get_menu_styles() {
  $styles = array();
  foreach (module_implements('paddle_menu_styles') as $module) {
    $function = "{$module}_paddle_menu_styles";
    $module_styles = $function();

    // Add the 'owning' module name to each engine info array, so
    // hooks/callbacks implemented by the module can be called later on.
    foreach ($module_styles as &$style) {
      $style['module'] = $module;
    }

    $styles += $module_styles;
  }

  // Sort the engines by weight.
  uasort($styles, 'drupal_sort_weight');

  return $styles;
}

/**
 * The search form which is placed in the header_top region on the admin theme.
 */
function paddle_core_header_top_search_form($form, &$form_state) {
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
    '#attributes' => array('id' => 'top-search-submit'),
  );

  $form['search'] = array(
    '#type' => 'textfield',
    '#title' => '',
    '#size' => 60,
    '#maxlength' => 128,
  );

  return $form;
}

/**
 * Submit handler for paddle_core_header_top_search_form.
 */
function paddle_core_header_top_search_form_submit($form, &$form_state) {
  // Search the content manager for the given title.
  $form_state['redirect'] = array(
    'admin/content_manager/list/search',
    array('query' => array('search_title' => trim($form_state['values']['search']))),
  );

  // To completely control the redirect destination, we need to remove the
  // 'destination' GET parameter, which would override our destination, if
  // present.
  unset($_GET['destination']);
}

/**
 * Implements hook_block_info().
 */
function paddle_core_block_info() {
  $blocks = array();

  $blocks['content_search'] = array(
    'info' => t('Content search'),
    'cache' => DRUPAL_NO_CACHE,
    'status' => 0,
    'visibility' => BLOCK_VISIBILITY_NOTLISTED,
  );

  $blocks['site_settings_menu'] = array(
    'info' => t('Site Settings Menu'),
    'cache' => DRUPAL_NO_CACHE,
    'status' => 0,
    'visibility' => BLOCK_VISIBILITY_NOTLISTED,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function paddle_core_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'content_search':
      $block['subject'] = '';
      $block['content'] = drupal_get_form('paddle_core_header_top_search_form');
      break;

    case 'site_settings_menu':
      $block['subject'] = '';
      $block['content'] = array(
        '#theme' => 'links__site_settings_menu',
        '#links' => array(
          'settings-page' => array(
            'href' => url('admin/site-settings', array('absolute' => TRUE)),
            'title' => '<span class="element-invisible">' . t('Settings') . '</span>',
            'html' => TRUE,
            'attributes' => array(
              'class' => array('site-settings-wrench'),
              'title' => t('Settings'),
            ),
          ),
          'site-name' => array(
            'href' => '<front>',
            'title' => variable_get('site_name', 'Drupal'),
            'attributes' => array(
              'class' => array('site-settings-name'),
            ),
          ),
          'help' => array(
            'href' => variable_get('paddle_helpdesk_url', 'http://support.kanooh.be/'),
            'title' => '<span class="element-invisible">' . t('Help') . '</span>',
            'html' => TRUE,
            'attributes' => array(
              'class' => array('site-settings-help'),
              'title' => t('Help'),
              'target' => '_blank',
            ),
          ),
        ),
      );

      break;
  }

  return $block;
}

/**
 * Implements hook_paddle_contextual_toolbar_actions_alter().
 */
function paddle_core_paddle_contextual_toolbar_actions_alter(&$actions) {
  $menu_item = menu_get_item();

  if (in_array($menu_item['path'], array(
    'admin/themes/%/edit',
    'admin/paddle-mega-dropdown/edit/%',
    'admin/content_manager/node/%/build_form',
    'node/%/webform/emails/%',
    'admin/content_manager/node/%/download',
  ))) {
    drupal_add_js(drupal_get_path('module', 'paddle_core') . '/js/cancel.js');
  }
}

/**
 * Implements hook_field_widget_form_alter().
 */
function paddle_core_field_widget_form_alter(&$element, &$form_state, $context) {
  // The addressfield country part is defaulted to "BE" and should not be
  // changed.
  $allow_country = array(
    'organizational_unit_node_form',
    'contact_person_node_form',
    'company_page_node_form',
  );

  if (!in_array($form_state['build_info']['form_id'], $allow_country)) {
    if ($context['field']['type'] == 'addressfield') {
      $element['country']['#access'] = FALSE;
    }
  }
}

/**
 * Implements hook_themes_enabled().
 */
function paddle_core_themes_enabled($theme_list) {
  foreach ($theme_list as $theme) {
    _block_rehash($theme);
    // Place the paddle_menu_display with the 1st level of the main menu
    // in the content top area.
    paddle_core_update_block($theme, 'first_level', 'paddle_menu_display', 'header_bottom');

    // Place the paddle_menu_display with the 4th level of the management menu
    // in the sidebar_first area.
    paddle_core_update_block($theme, 'current_level_plus_one', 'paddle_menu_display', 'content_sub_top');

    // Place the paddle_menu_display with the 1st level of the top menu
    // in the service_links region.
    paddle_core_update_block($theme, 'top_menu', 'paddle_menu_display', 'service_links');

    // Place the paddle_menu_display with the 1th level of the footer menu
    // in the footer region.
    paddle_core_update_block($theme, 'footer_menu', 'paddle_menu_display', 'footer');

    // Place the paddle menu display with the 1th level of the disclaimer menu
    // in the disclaimer region.
    paddle_core_update_block($theme, 'disclaimer_menu', 'paddle_menu_display', 'disclaimer');

    // Place the Login block in the sidebar of the frontend theme.
    paddle_core_update_block($theme, 'login', 'user', 'sidebar_first');

    // Place the search_api block in the region specified.
    paddle_core_update_block($theme, 'search', 'search_api_page', 'service_links');
  }
}

/**
 * Function to update the block settings.
 *
 * @param string $theme
 *   The theme to adjust the block for.
 * @param string $delta
 *   The delta of the block.
 * @param string $module
 *   The module delivering the block.
 * @param string $region
 *   The region to place the block in.
 */
function paddle_core_update_block($theme, $delta, $module, $region) {
  db_update('block')
    ->fields(array(
      'region' => $region,
      'status' => 1,
      'title' => '<none>',
      'theme' => $theme,
    ))
    ->condition('module', $module)
    ->condition('theme', $theme)
    ->condition('delta', $delta)
    ->execute();
}

/**
 * Implements hook_menu_site_status_alter().
 */
function paddle_core_menu_site_status_alter(&$menu_site_status, $path) {
  // If the site is in our "maintenance mode" we want to remove access to pages
  // for anonymous users so we put the site in regular maintenance mode.
  if (user_is_anonymous() && variable_get('paddle_maintenance_mode', 0) && !path_is_admin($path)) {
    $menu_site_status = MENU_SITE_OFFLINE;
  }
}

/**
 * Implements hook_node_type_insert().
 */
function paddle_core_node_type_insert($info) {
  // When a new node type is created in the system, it enables the cloning by
  // default. But for overview pages, it should not be enabled.
  variable_set('clone_reset_' . $info->type, 1);
  $node_types = array_fill_keys(array_keys(node_type_get_types()), 0);
  $node_types['paddle_overview_page'] = 'paddle_overview_page';
  $omitted = variable_get('clone_omitted', $node_types);
  $omitted[$info->type] = 0;
  variable_set('clone_omitted', $omitted);
}

/**
 * Implements hook_node_view().
 */
function paddle_core_node_view($node, $view_mode, $langcode) {
  if ($node->type != 'news_item') {
    unset($node->content['field_paddle_featured_image']);
  }
}

/**
 * Implements hook_preprocess_html().
 */
function paddle_core_preprocess_html(&$variables) {
  $node = menu_get_object();
  global $base_url;

  // Check if the menu item is a node.
  if ($node) {
    // Set the meta tag for the title.
    $seo_title = field_get_items('node', $node, 'field_paddle_seo_title');
    if (!empty($seo_title[0]['value'])) {
      $title = strip_tags($seo_title[0]['value']);
    }
    else {
      if (!empty($node->title)) {
        $title = strip_tags($node->title);
      }
    }

    // Only add the meta tag when the title variable is not empty.
    if (!empty($title)) {
      $og_title_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'property' => 'og:title',
          'content' => $title,
        ),
      );
      $tc_title_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'name' => 'twitter:title',
          'content' => $title,
        ),
      );

      // Add the title meta tag to head.
      drupal_add_html_head($og_title_tag, 'meta_og_title');
      drupal_add_html_head($tc_title_tag, 'meta_tc_title');
    }

    // Set the meta tag for the description.
    $seo_description = field_get_items('node', $node, 'field_paddle_seo_description');

    if (!empty($seo_description[0]['value'])) {
      $description = strip_tags($seo_description[0]['value']);
    }
    elseif (!empty(field_get_items('node', $node, 'body'))) {
      $body = field_get_items('node', $node, 'body');
      // Only if the description is taken from the body field we need to
      // truncate it to 160 characters.
      $description = strip_tags($body[0]['value']);
      $description = truncate_utf8($description, 157, FALSE, TRUE);
    }
    else {
      // There has to be a description otherwise tc validation fails.
      $description = $node->title;
    }

    // Only add the meta tag when the description variable is not empty.
    if (!empty($description)) {
      $description_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'name' => 'description',
          'content' => $description,
        ),
      );

      $og_description_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'property' => 'og:description',
          'content' => $description,
        ),
      );
      $tc_description_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'name' => 'twitter:description',
          'content' => $description,
        ),
      );

      // Add the description meta tag to head.
      drupal_add_html_head($description_tag, 'meta_description');
      drupal_add_html_head($og_description_tag, 'meta_og_description');
      drupal_add_html_head($tc_description_tag, 'meta_tc_description');
    }

    $keywords = array();
    foreach (
      array(
        'field_paddle_tags',
        'field_paddle_general_tags',
      ) as $term_field) {
      $terms = field_get_items('node', $node, $term_field);

      // Set the keywords meta tag.
      if (!empty($terms)) {
        foreach ($terms as $term) {
          if ($tag = taxonomy_term_load($term['tid'])) {
            $keywords[] = $tag->name;
          }
        }
      }
    }

    if (!empty($keywords)) {
      $keywords_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'name' => 'keywords',
          'content' => implode(',', $keywords),
        ),
      );

      // Add keywords meta tag to head.
      drupal_add_html_head($keywords_tag, 'meta_keywords');
    }

    // Add the Open graph & Twitter Image meta-tag for Social Media Sharing.
    // If a featured image exists, we use the featured image, otherwise the
    // default shared image specified in the System settings.
    $featured_image = field_get_items('node', $node, 'field_paddle_featured_image');
    $shared_image_atom = variable_get('paddle_default_sharing_image', array());

    if ($featured_image) {
      $shared_image_id = $featured_image[0]['sid'];
    }
    elseif (!empty($shared_image_atom)) {
      $shared_image_id = $shared_image_atom[0];
    }

    if (!empty($shared_image_id)) {
      $shared_image = scald_atom_load($shared_image_id);
      $image_path = $shared_image->thumbnail_source;
      $styled_path = image_style_path('large', $image_path);

      if (!file_exists($styled_path)) {
        image_style_create_derivative(image_style_load('large'), $image_path, $styled_path);
      }

      $image_url = file_create_url($styled_path);
      $og_image_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'property' => 'og:image',
          'content' => $image_url,
        ),
      );
      $tc_image_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'name' => 'twitter:image',
          'content' => $image_url,
        ),
      );

      drupal_add_html_head($tc_image_tag, 'meta_tc_image');
      drupal_add_html_head($og_image_tag, 'meta_og_image');

      // Get the height and width of the image as well so Open Graph
      // can load the image faster.
      $image_info = image_get_info($styled_path);
      $image_width = $image_info['width'];
      $image_height = $image_info['height'];
      $og_image_width_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'property' => 'og:image:width',
          'content' => $image_width,
        ),
      );
      $tc_image_width_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'name' => 'twitter:image:width',
          'content' => $image_width,
        ),
      );
      $og_image_height_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'property' => 'og:image:height',
          'content' => $image_height,
        ),
      );
      $tc_image_height_tag = array(
        '#type' => 'html_tag',
        '#tag' => 'meta',
        '#attributes' => array(
          'name' => 'twitter:image:height',
          'content' => $image_height,
        ),
      );
      drupal_add_html_head($og_image_width_tag, 'meta_og_image_width');
      drupal_add_html_head($og_image_height_tag, 'meta_og_image_height');
      drupal_add_html_head($tc_image_width_tag, 'meta_twitter_image_width');
      drupal_add_html_head($tc_image_height_tag, 'meta_twitter_image_height');
    }

    // Add Twitter card tags.
    $tc_card_tag = array(
      '#type' => 'html_tag',
      '#tag' => 'meta',
      '#attributes' => array(
        'name' => 'twitter:card',
        'content' => "summary",
      ),
    );
    $tc_site_tag = array(
      '#type' => 'html_tag',
      '#tag' => 'meta',
      '#attributes' => array(
        'name' => 'twitter:url',
        'content' => $base_url,
      ),
    );

    drupal_add_html_head($tc_card_tag, 'meta_tc_card_type');
    drupal_add_html_head($tc_site_tag, 'meta_tc_site');
  }
}

/**
 * Update panelizer so they adjust to panelizer changes.
 *
 * @param string $entity_type
 *   The entity type of the entities that need updating.
 * @param object $entity
 *   The entity that needs updating.
 */
function paddle_core_update_panelizer_entity($entity_type = 'node', $entity) {
  // Get the default display of the panelizer object.
  ctools_include('export');
  $panelizers = ctools_export_load_object('panelizer_defaults');

  $panelizer = $panelizers["$entity_type:$entity->type:default"];
  $default_display = $panelizer->display;
  $default_content = $default_display->content;

  $updated_displays = array();
  if (
    !empty($entity->panelizer['page_manager']->display->did) &&
    $entity->panelizer['page_manager']->display->did != 'new' &&
    !in_array($entity->panelizer['page_manager']->display->did, $updated_displays)
  ) {
    $updated_displays[] = $entity->panelizer['page_manager']->did;
    $display = $entity->panelizer['page_manager']->display;

    // Loop over the content in the entity and preserve the content in the
    // right and bottom columns because these stay unaltered if the renderer
    // comes from the content_region pipeline.
    if ($panelizer->pipeline == 'paddle_content_region') {
      foreach ($display->content as $pid => $pane) {
        if (!in_array($pane->panel, array('right', 'bottom'))) {
          unset($display->content[$pid]);
        }
      }
    }

    // For every existing pane, create a new pane and hand it in the display.
    foreach ($default_content as $pid => $pane) {
      if (
        $panelizer->pipeline != 'paddle_content_region' ||
        ($panelizer->pipeline == 'paddle_content_region' &&
          !in_array($pane->panel, array('right', 'bottom')))
      ) {
        $new_pane = panels_new_pane($pane->type, $pane->subtype);

        foreach ($pane as $key => $value) {
          if (!in_array($key, array('type', 'subtype'))) {
            $new_pane->{$key} = $pane->{$key};
          }
        }

        $display->content[$new_pane->pid] = $new_pane;
        $display->panels[$new_pane->panel][] = $new_pane->pid;
      }
    }

    panels_save_display($display);
  }
}

/**
 * Gets all revisions for all entities fetched by type and bundles.
 *
 * @param string $entity_type
 *   The entity type to search for.
 * @param array $bundles
 *   The bundles that the entities may be part of.
 *
 * @return array
 *   All revisions of the fetched entities.
 */
function paddle_core_get_entity_revisions($entity_type, $bundles) {
// Get all required entities.
  $entities = array();
  $query = new EntityFieldQuery;
  $query->entityCondition('entity_type', $entity_type, '=');

  if (!empty($bundles)) {
    $query->propertyCondition('type', $bundles, 'IN');
  }

  $results = $query->execute();

  if (!empty($results['node'])) {
    $revisions_per_node = array();
    foreach ($results['node'] as $nid => $node) {
      $revisions_per_node[$nid] = node_revision_list($node);
    }

    foreach ($revisions_per_node as $nid => $revisions) {
      foreach ($revisions as $revision) {
        $entities[] = node_load($nid, $revision->vid);
      }
    }
    return $entities;
  }
  return $entities;
}

/**
 * Get the available footer styles.
 *
 * @return array
 *   An array with info on available footer styles, keyed by their machine
 *   names.
 */
function paddle_core_get_footer_styles() {
  $formatted_styles = array();
  $module_styles = array();

  foreach (module_implements('paddle_footer_styles') as $module) {
    $function = "{$module}_paddle_footer_styles";
    $module_styles[] = $function();
  }

  // Sort the engines by weight.
  uasort($module_styles, 'drupal_sort_weight');

  // Format the array.
  if (!empty($module_styles)) {
    foreach ($module_styles as $index => $content) {
      if (!empty($content)) {
        foreach ($content as $key => $value) {
          $formatted_styles[$key] = $value;
        }
      }
    }
  }

  return $formatted_styles;
}

/**
 * Checks if the address field is empty.
 *
 * @param array $address
 *   The address array to check.
 *
 * @return bool
 *   Is the address field empty or not.
 */
function paddle_core_is_address_empty($address) {
  $empty_address = TRUE;

  if (!empty($address)) {
    foreach ($address as $key => $value) {
      $address[$key] = check_plain($value);
      if ($key != 'country') {
        // Ignore country because that always has a value.
        // Check if any other key has a non empty value.
        if (!empty($address[$key])) {
          $empty_address = FALSE;
        }
      }
    }
  }

  return $empty_address;
}

/**
 * Gets an array with languages we support for back end language.
 *
 * @return array
 *   Array containing the back end languages we support.
 */
function paddle_core_supported_back_end_languages() {
  return array(
    'nl',
    'en',
    'fr',
  );
}

/**
 * Implements hook_l10n_update_languages_alter().
 *
 * Only check for translation updates from languages that are available in the
 * back end.
 */
function paddle_core_l10n_update_languages_alter(array &$languages) {
  $available = array_flip(paddle_core_supported_back_end_languages());
  $languages = array_intersect_key($languages, $available);
}

/**
 * Determines if the Paddle site is multilingual.
 *
 * @return bool
 *   Whether the site is multilingual or not.
 */
function paddle_core_is_multilingual() {
  if (module_exists('paddle_i18n')) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @see user_admin_settings()
 * @see xmlsitemap_add_link_bundle_settings()
 */
function paddle_core_form_user_admin_settings_alter(&$form, $form_state) {
  $form['email_admin_created']['user_mail_register_admin_created_subject']['#default_value'] = _paddle_core_get_mail_text('user_mail_register_admin_created_subject', NULL, FALSE);
  $form['email_admin_created']['user_mail_register_admin_created_body']['#default_value'] = _paddle_core_get_mail_text('user_mail_register_admin_created_body', NULL, FALSE);
  $form['email_password_reset']['user_mail_password_reset_subject']['#default_value'] = _paddle_core_get_mail_text('user_mail_password_reset_subject', NULL, FALSE);
  $form['email_password_reset']['user_mail_password_reset_body']['#default_value'] = _paddle_core_get_mail_text('user_mail_password_reset_body', NULL, FALSE);
}

/**
 * Implements hook_variable_type_info_alter().
 */
function paddle_core_variable_type_info_alter(&$info) {
  $info['user_mail']['repeat']['default callback'] = 'paddle_core_mail_default';
}

/**
 * Default callback for user mail variables.
 */
function paddle_core_mail_default($variable, $options) {
  $variable_list = array(
    'user_mail_register_admin_created_subject',
    'user_mail_register_admin_created_body',
    'user_mail_password_reset_subject',
    'user_mail_password_reset_body',
  );

  if (in_array($variable, $variable_list)) {
    return _paddle_core_get_mail_text($variable, $options['language']);
  }
  else {
    return user_variable_mail_default($variable, $options);
  }
}

/**
 * Implements hook_mail_alter().
 */
function paddle_core_mail_alter(&$message) {
  if ($message['module'] == 'user') {
    $language = $message['language'];
    $variables = array('user' => $message['params']['account']);
    $key = $message['key'];

    $components = array('subject', 'body');
    foreach ($components as $component) {
      $text = _paddle_core_get_mail_text('user_mail_' . $key . '_' . $component, $language, FALSE);
      if ($text) {
        $text = token_replace($text, $variables, array(
          'language' => $language,
          'callback' => 'i18n_user_user_mail_tokens',
          'sanitize' => FALSE,
        ));

        switch ($component) {
          case 'subject':
            $message[$component] = $text;
            break;

          case 'body':
            $message[$component] = array($text);
            break;
        }
      }
    }
    // The one time login URL needs to be replaced separately.
    if (isset($message['body'][0]) && isset($message['to'])) {
      $account = user_load_by_mail($message['to']);
      if (!is_object($account)) {
        return;
      }
      $login_link = user_pass_reset_url($account);
      $message['body'][0] = str_replace("[user:one-time-login-url]", $login_link, $message['body'][0]);
    }
  }
}

/**
 * Get the text to be applied to the account setting mails.
 *
 * @param string $variable
 *   The variable which we need to retrieve the text for.
 * @param object $language
 *   The language of the text.
 * @param bool $replace
 *   If we need to replace the tokens in the text or not.
 *
 * @return mixed
 *   The text to be inserted in the mail.
 *
 * @see _user_mail_text()
 */
function _paddle_core_get_mail_text($variable, $language = NULL, $replace = TRUE) {
  $lang_code = isset($language) ? $language->language : NULL;
  $text = '';

  if ($admin_setting = variable_get($variable, FALSE)) {
    // An admin setting overrides the default string.
    $text = $admin_setting;
  }
  else {
    switch ($variable) {
      case 'user_mail_register_admin_created_subject':
        $text = t('New account on the website of [site:name]', array(), array('langcode' => $lang_code));
        break;

      case 'user_mail_register_admin_created_body':
        $text = t('Dear [user:name],

A site administrator at [site:name] has created an account for you. You may now log in by clicking this link or copying and pasting it to your browser:

[user:one-time-login-url]

This link can only be used once to log in and will lead you to a page where you can set your password.
After setting your password, you will be able to log in.

Link: [site:url]
Username: [user:name]

This website is developed using the Paddle CMS. Are you not familiar with it yet?
- It is possible to receive a customised training session. To receive a customised training session contact us on sales@paddle.be or call 02 307 79 08
- There is also the possibility to sign in for a free demo session. During such a demo session we show the general functionality of the CMS but we shall not discuss all available topics. Once you have completed the two hour demo session you are ready to create and manage your web pages. Sign in for our demo session at https://www.paddle.be/nl/vraag-jouw-gratis-demosessie-aan

Useful links
- FAQ: http://support.paddle.be/nl/support/solutions
- Help desk: http://support.paddle.be/nl/support/login/new
- Our help desk is available 24/7 at 02 307 79 08
- Have you forgotten your password? Here you are able to read how to recover your account:
http://support.paddle.be/solution/articles/3000021042-hoe-maak-ik-een-nieuw-wachtwoord-aan-/nl.

If you would have additional questions do not hesitate to contact us.

Yours sincerely,

--  [site:name] team', array(), array('langcode' => $lang_code));
        break;

      case 'user_mail_password_reset_subject':
        $text = t('New password for [user:name] at [site:url]', array(), array('langcode' => $lang_code));
        break;

      case 'user_mail_password_reset_body':
        $text = t('Dear [user:name],

A request to reset the password for your account has been made at [site:name].

You may now set up a new password by clicking this link or copying and pasting it to your browser:

[user:one-time-login-url]

You are able to enter a new password on this page. You are required to confirm your password by inserting it a second time, then you are allowed to save it. Once saved, you can log in again with your new password.

Warning: This link can only be used once. The link is valid for just one day. Once the day has passed, the link will be expired. Nothing will happen if you did not use the link. Would you like to change your password again after not using the link for a day? Then you are required to request a new link.

Yours sincerely,

--  [site:name] team', array(), array('langcode' => $lang_code));
        break;
    }
  }

  if ($replace) {
    return token_replace(
      $text,
      array(),
      array(
        'language' => $language,
        'callback' => 'user_mail_tokens',
        'sanitize' => FALSE,
        'clear' => TRUE,
      )
    );
  }

  return $text;
}
